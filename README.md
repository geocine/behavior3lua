# Behavior Tree Framework for Lua

By coincidence, my work in recent years has always involved game AI. The commonly seen behavior tree + blackboard online doesn't seem to be able to meet complex design requirements, nor is it likely that designers can configure this kind of behavior tree themselves. Therefore, I made some small modifications to the blackboard of the behavior tree, making the behavior tree more like a code editor. We programmers provide a small number of behavior nodes, allowing designers to implement the logic they want by editing the behavior tree. This can also be considered a kind of liberation for game programmers.

## Basic Concepts

#### Node Data Structure
```lua
{
    name = 'find_enemy',        -- Node name
    desc = 'Find enemy',        -- Description  
    args = {w = 100, h = 50},   -- Constant configuration
    input = {'var1', 'var2'},   -- Input variables
    output = {'target'},        -- Output variables
    children = {}               -- Child nodes
}
```

#### Constants
Usually fixed values, such as range, type, etc.

#### Input/Output Variables
Because nodes have mutual influence on each other, for example, this node may use data generated by the previous node, so most behavior tree designers provide a data structure to record the running state of the behavior tree, called a "blackboard".

I swapped a concept, treating the node as a function to execute. As defined in the above node, input={'var1', 'var2'} means that before executing the node, var1 and var2 are retrieved from the blackboard and passed in as parameters. After the node executes, the result is returned and written to the target variable. The whole process is like the following pseudocode:

```lua
function find_enemy(var1, var2)
    local w, h = args.w, args.h
    // do find enemy in range w, h
    ...
    return target
end
```

After this node is executed, the target variable on the blackboard is written with the found target, and the subsequent nodes can use the target variable as input.

```lua
{
    name = 'attack',
    desc = 'Attack enemy',
    args = {skill = 101},
    input = {'target'},
}
```

#### Status Return
+ SUCCESS 
+ FAIL 
+ RUNNING 
+ ABORT 

## Composite Nodes
+ Parallel: Execute in parallel, execute all child nodes and return true
+ Sequence: Execute in sequence, execute all child nodes until false is returned
+ Selector: Selective execution, execute all child nodes until true is returned

## Decorator Nodes
+ Not: Invert
+ AlwaysSuccess
+ AlwaysFail

## Behavior Nodes
+ Wait: Wait for a period of time before continuing execution
+ MoveToTarget: Move to target
+ GetHp: Get health value
+ Attack: Attack target

## API
+ new: Create a new behavior tree object
+ run: Execute one tick
+ set_var: Set variable
+ get_var: Get variable

## Running Status
When making a behavior tree, you can't avoid the issue of running status. If a behavior tree scheme doesn't have a running status, it can only be used as a decision tree, not for continuous actions. To implement the running status, the key is how to recover from the node that ran last time. The node call of the behavior tree is very similar to the call stack of a program. In fact, the composite nodes can be slightly modified to achieve this:
+ As long as any child node returns RUNNING, immediately return RUNNING.
+ Push the node onto the stack before running the node. If the node returns RUNNING, interrupt the execution and wait for the next tick to wake up. If it returns SUCCESS or FAIL, pop it off the stack and continue executing.

![](readme/running.png)

## Editor
I developed a general behavior tree editor using Alibaba's g6 graphics library and packaged it into an exe version using electron. It's still quite rudimentary at the moment. Interested friends can pay attention to [behavior3editor](https://github.com/zhandouxiaojiji/behavior3editor)

![](readme/editor.png)

## Run Test Cases
+ Export node definitions
```
lua export_node.lua
```
+ Run test
```
lua test.lua
```

## Debugging Solution
My previous approach was to send the execution results of all nodes for each tick to the editor and display them in the editor, which was very detailed but actually quite useless in practical application, with too much redundant data making it dazzling. My current approach is to mark the nodes that need debugging when editing the behavior tree. When the behavior tree runs to this node, it prints the logs related to this node, such as time/frame number, execution results, and all variable values.

## About
I have used this scheme in several projects, including action, card, MOBA, and MMO types. By providing thirty to forty types of nodes, designers can basically configure a very complex AI themselves. Of course, it can also be used in skill systems and other systems that require more intuitive logic representation. This is just one approach. If any passing experts have any suggestions or views, welcome to raise an Issue or join the group for discussion (QQ group: 644761605)